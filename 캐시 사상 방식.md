# 캐시 사상 방식
  
  
  캐시의 사상 방식에는 직접 사상, 연관 사상, 집합 연관 사상 3가지가 있다.
  
  
## 직접 사상 (Direct Mapping)
  
  메인메모리와 캐시를 똑같은 크기로 나누고 순서대로 매핑하는 것이다.
  
  이때 메인 메모리를 블록단위로 나누고 캐시는 라인 단위로 나누는데, 한 블록 사이즈와 한 라인 사이즈가 같도록 한다.
  
  만약 캐시의 크기가 16워드이고, 메모리의 크기가 64워드 라고 하자. 블럭하나가 4워드면 블럭은 총 16개이고, 
  
  라인은 4개가 된다. 이때 64를 표현하기 위해서는 6bit가 필요하므로 000000 ~ 111111이 각 워드의 주소이다.
  
  블럭하나가 4워드이기 때문에 뒤에 2bit가 블럭 하나에서 몇번째 워드인지를 나타내며(offset), 블럭이 16개므로 앞의 4bit가 몇번째 블럭인지를
  
  나타내게 된다.(block number)  
  
  ex) 111111 이면 1111 = 15 11 = 3 이므로 16번째의 4번째 워드임을 알 수 있다. (0 부터 세야한다.)
  
  앞에 4bit가 몇번째 블록인지를 나타낸다고 했는데(block number), 여기서 또 앞 2bit는 tag, 뒤의 2bit는 라인 번호를 나타낸다. 
  
  tag 2bit가 캐시 내에 어디 주소부터 매핑될 것인지, line number 2bit는 tag가 정해준 주소부터 몇번째 라인에 블록이 들어갈 것인지를 나타낸다.
  
  
  ```
  ex) 25워드를 직접 사상으로 매핑해보자.
  
  25 = 011001 이고
  
  tag는 01, line number는 10, block number는 0110, offset은 01이다.
  
  이는 메모리 내의 7번째 (0110) 블록의 2번째(01) 워드를 캐시의 7번째(01 * 한 블록의 라인 수(4) + 3번째(10))에 매핑하겠단 소리다. 
  
  ```
  
  결국 직접 사상은 블럭 0번을 캐시 0라인에, 블럭 1번을 캐시 1라인에, 블럭 2번을 캐시 2라인에 ...
  
  이렇게 매핑하는 방식이다.
  
  단점은 이런 매핑 규칙으로 인해 캐시에서 자주 사용되던 블록이 교체될 수 있다는 것이다.ㅠㅠ (충돌이 잦다)
  
  장점은 사상 과정이 간단하다는 점!
  
  
## 완전 연관 사상 (Fully-Associative Mapping)
  
  
  메인 메모리의 블록이 캐시의 임의의 슬롯에 적재될 수 있는 방식!
  
  융통성이 있으나 모든 슬롯에 대해 태그가 일치하는지 검사해야하므로, 검사 시간이 오래걸린다!!!!
  
  캐시 미스시 주기억장치에서 원하는 데이터를 fatch해 와야되는데 이때 캐시 교체 알고리즘이 사용된다.
  
  
## 집합 연관 사상 (n-way Set-associative mapping)
  
  
  직접 사상과 완전 연관 사상을 조합한 방식이다. 인덱스(block number)가 가리키는 공간이 n개면 n-way set associative!
  
  직접 사상 방식은 인덱스에 1개의 블럭이지만, n개를 넣을 수 있다는 소리다.
  
  만일 모든 블럭을 한 인덱스에 넣는다? 그럼 그건 완전 연관 사상이다.
  
  집합 연관 사상에서는 이러한 n개의 블럭이 들어간 한 인덱스를 집합(set)이라고 한다.
  
  검색할 시 한 set의 모든 블럭을 뒤져야하는 것이다.
  
  예를들면 32bit주소에서 맨뒤 2bit는 버리고 인덱스가 256개면 8bit가 인덱스를 나타낸다.
  
  나머지 22bit는 각 블록의 Tag와 비교하여 hit했는지를 판단한다.  
  
  
  
  
  
 
  
  
